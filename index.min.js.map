{
  "version": 3,
  "sources": ["src/index.js"],
  "sourcesContent": ["const layers = {};\n\nconst times = /(-?(?:\\d+\\.?\\d*|\\d*\\.?\\d+)(?:e[-+]?\\d+)?)\\s*([\\p{L}]*)/iu;\n\nparse.millisecond = parse.ms = 1;\nparse.second = parse.sec = parse.s = parse[\"\"] = parse.ms * 1000;\nparse.minute = parse.min = parse.m = parse.s * 60;\nparse.hour = parse.hr = parse.h = parse.m * 60;\nparse.day = parse.d = parse.h * 24;\nparse.week = parse.wk = parse.w = parse.d * 7;\nparse.year = parse.yr = parse.y = parse.d * 365.25;\nparse.month = parse.b = parse.y / 12;\n\n// Returns the time in milliseconds\nfunction parse(str) {\n  if (str === null || str === undefined) return null;\n  if (typeof str === \"number\") return str;\n  // ignore commas/placeholders\n  str = str.toLowerCase().replace(/[,_]/g, \"\");\n  let [_, value, units] = times.exec(str) || [];\n  if (!units) return null;\n  const unitValue = parse[units] || parse[units.replace(/s$/, \"\")];\n  if (!unitValue) return null;\n  const result = unitValue * parseFloat(value, 10);\n  return Math.abs(Math.round(result));\n}\n\nlayers.expire = (store) => {\n  // Item methods\n  const get = async (key) => {\n    if (!(await store.has(key))) return null;\n    const { data, expire } = await store.get(key);\n    if (expire === null) return data;\n    const diff = expire - new Date().getTime();\n    if (diff <= 0) return null;\n    return data;\n  };\n  const set = async (key, data, { expire = null } = {}) => {\n    const time = parse(expire);\n    const expDiff = time !== null ? new Date().getTime() + time : null;\n    return store.set(key, { expire: expDiff, data });\n  };\n  const has = async (key) => (await store.get(key)) !== null;\n  const del = store.del;\n\n  // Group methods\n  const keys = store.keys;\n  const clear = store.clear;\n\n  return { get, set, has, del, keys, clear };\n};\n\nlayers.memory = (store) => {\n  // Item methods\n  const get = async (key) => store.get(key) || null;\n  const set = async (key, data) => store.set(key, data);\n  const has = async (key) => store.has(key);\n  const del = async (key) => store.delete(key);\n\n  // Group methods\n  const keys = async (prefix = \"\") =>\n    [...(await store.keys())].filter((k) => k.startsWith(prefix));\n  const clear = () => store.clear();\n\n  return { get, set, has, del, keys, clear };\n};\n\nlayers.storage = (store) => {\n  // Item methods\n  const get = async (key) => (store[key] ? JSON.parse(store[key]) : null);\n  const set = async (key, data) => store.setItem(key, JSON.stringify(data));\n  const has = async (key) => key in store;\n  const del = async (key) => store.removeItem(key);\n\n  // Group methods\n  const keys = async (prefix = \"\") =>\n    Object.keys(store).filter((k) => k.startsWith(prefix));\n  const clear = () => store.clear();\n\n  return { get, set, has, del, keys, clear };\n};\n\nlayers.cookie = () => {\n  const get = async (key) => {\n    const value =\n      document.cookie\n        .split(\"; \")\n        .filter(Boolean)\n        .find((row) => row.startsWith(key + \"=\"))\n        ?.split(\"=\")[1] || null;\n    return JSON.parse(decodeURIComponent(value));\n  };\n\n  const set = async (key, data, { expire = null } = {}) => {\n    const time = parse(expire);\n    const now = new Date().getTime();\n    const expireStr =\n      time !== null ? `; expires=${new Date(now + time).toUTCString()}` : \"\";\n    const value = encodeURIComponent(JSON.stringify(data));\n    document.cookie = key + \"=\" + value + expireStr;\n  };\n  const has = async (key) => (await keys()).includes(key);\n  const del = async (key) => set(key, \"\", { expire: -100 });\n\n  // Group methods\n  const keys = async (prefix = \"\") =>\n    document.cookie\n      .split(\";\")\n      .map((l) => l.split(\"=\")[0].trim())\n      .filter(Boolean)\n      .filter((k) => k.startsWith(prefix));\n  const clear = async () => {\n    await Promise.all((await keys()).map(del));\n  };\n\n  return { get, set, has, del, keys, clear };\n};\n\nlayers.redis = (store) => {\n  const get = async (key) => {\n    const client = await store;\n    const value = await client.get(key);\n    if (!value) return null;\n    return JSON.parse(value);\n  };\n  const set = async (key, value, { expire = null } = {}) => {\n    if (value === null || expire === 0) return del(key);\n    const client = await store;\n    const exp = parse(expire);\n    const EX = exp ? Math.round(exp / 1000) : undefined;\n    return client.set(key, JSON.stringify(value), { EX });\n  };\n  const has = async (key) => Boolean(await (await store).exists(key));\n  const del = async (key) => (await store).del(key);\n\n  const keys = async (prefix = \"\") => (await store).keys(prefix + \"*\");\n  const clear = async () => (await store).flushAll();\n  const close = async () => (await store).quit();\n\n  return { get, set, has, del, keys, clear, close };\n};\n\nlayers.localForage = (store) => {\n  const get = (key) => store.getItem(key);\n  const set = (key, value) => store.setItem(key, value);\n  const has = async (key) => (await get(key)) !== null;\n  const del = (key) => store.removeItem(key);\n\n  const keys = async (prefix = \"\") =>\n    (await store.keys()).filter((k) => k.startsWith(prefix));\n  const clear = () => store.clear();\n\n  return { get, set, has, del, keys, clear };\n};\n\nlayers.cloudflare = (store) => {\n  const get = async (key) => {\n    const data = await store.get(key);\n    if (!data) return null;\n    return JSON.parse(data);\n  };\n  const set = async (key, value, { expire }) => {\n    if (value === null || expire === 0) return del(key);\n    const client = await store;\n    const exp = parse(expire);\n    const expirationTtl = exp ? Math.round(exp / 1000) : undefined;\n    return client.set(key, JSON.stringify(value), { expirationTtl });\n  };\n  const has = (key) => Boolean(store.get(key));\n  const del = (key) => store.delete(key);\n  const keys = (prefix) => store.list({ prefix });\n  return { get, set, has, del, keys, clear };\n};\n\nlayers.file = (file) => {\n  const fsProm = (async () => {\n    // For the bundler, it doesn't like it otherwise\n    const lib = [\"node:fs\", \"promises\"].join(\"/\");\n    const fsp = await import(lib);\n    // We want to make sure the file already exists, so attempt to\n    // create it (but not OVERWRITE it, that's why the x flag) and\n    // it fails if it already exists\n    await fsp.writeFile(file.pathname, \"{}\", { flag: \"wx\" }).catch((err) => {\n      if (err.code !== \"EEXIST\") throw err;\n    });\n    return fsp;\n  })();\n  const getContent = async () => {\n    const fsp = await fsProm;\n    const text = await fsp.readFile(file.pathname, \"utf8\");\n    if (!text) return {};\n    return JSON.parse(text);\n  };\n  const setContent = async (data) => {\n    const fsp = await fsProm;\n    await fsp.writeFile(file.pathname, JSON.stringify(data, null, 2));\n  };\n  const get = async (key) => {\n    const data = await getContent();\n    return data[key] ?? null;\n  };\n  const set = async (key, value) => {\n    const data = await getContent();\n    data[key] = value;\n    await setContent(data);\n  };\n  const has = async (key) => (await get(key)) !== null;\n  const del = async (key) => {\n    const data = await getContent();\n    delete data[key];\n    await setContent(data);\n  };\n  const keys = async (prefix = \"\") => {\n    const data = await getContent();\n    return Object.keys(data).filter((k) => k.startsWith(prefix));\n  };\n  const clear = async () => {\n    await setContent({});\n  };\n  return { get, set, has, del, keys, clear };\n};\n\nconst getStore = async (store) => {\n  // Convert it to the normalized kv, then add the expiry layer on top\n  if (store instanceof Map) {\n    return layers.expire(layers.memory(store));\n  }\n\n  if (typeof localStorage !== \"undefined\" && store === localStorage) {\n    return layers.expire(layers.storage(store));\n  }\n\n  if (typeof sessionStorage !== \"undefined\" && store === sessionStorage) {\n    return layers.expire(layers.storage(store));\n  }\n\n  if (store === \"cookie\") {\n    return layers.cookie();\n  }\n\n  if (store.defineDriver && store.dropInstance && store.INDEXEDDB) {\n    return layers.expire(layers.localForage(store));\n  }\n\n  if (store.protocol && store.protocol === \"file:\") {\n    return layers.expire(layers.file(store));\n  }\n\n  if (store.pSubscribe && store.sSubscribe) {\n    return layers.redis(store);\n  }\n\n  if (store?.constructor?.name === \"KvNamespace\") {\n    return layers.cloudflare(store);\n  }\n\n  // \u00AF\\_(\u30C4)_/\u00AF\n  return null;\n};\n\nexport default function compat(storeClient = new Map()) {\n  return new Proxy(\n    {},\n    {\n      get: (_, key) => {\n        return async (...args) => {\n          const store = await getStore(await storeClient);\n          // Throw at the first chance when the store failed to init:\n          if (!store) {\n            throw new Error(\"Store is not valid\");\n          }\n          // The store.close() is the only one allowed to be called even\n          // if it doesn't exist, since it's optional in some stores\n          if (!store[key] && key === \"close\") return null;\n          return store[key](...args);\n        };\n      },\n    }\n  );\n}\n"],
  "mappings": "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",
  "names": ["layers", "times", "parse", "str", "_", "value", "units", "unitValue", "result", "store", "get", "key", "data", "expire", "set", "time", "expDiff", "has", "del", "keys", "clear", "prefix", "k", "row", "now", "expireStr", "l", "client", "exp", "EX", "expirationTtl", "file", "fsProm", "fsp", "err", "getContent", "text", "setContent", "getStore", "compat", "storeClient", "args"]
}
