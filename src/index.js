/**
 * A number, or a string containing a number.
 * @typedef {(number|string|object|array)} Value
 */

import clients from "./clients/index.js";
import { createId, isClass, parse } from "./utils.js";

// #region Store
class Store {
  PREFIX = "";

  constructor(clientPromise = new Map()) {
    this.promise = Promise.resolve(clientPromise).then(async (client) => {
      if (client?.open) await client.open();
      if (client?.connect) await client.connect();
      this.client = this.#find(client);
      this.#validate(this.client);
      this.promise = null;
      return client;
    });
  }

  // #region #client()
  #find(store) {
    // Already a fully compliant KV store
    if (store instanceof Store) return store.client;

    // One of the supported ones, so we receive an instance and
    // wrap it with the client wrapper
    for (let client of Object.values(clients)) {
      if (client.test && client.test(store)) {
        return new client(store);
      }
    }

    // A raw one, we just receive the single instance to use directly
    if (isClass(store)) {
      return new store();
    }
    return store;
  }

  // #region #validate()
  #validate(client) {
    if (!client.set || !client.get || !client.iterate) {
      throw new Error(
        "A client should have at least a .get(), .set() and .iterate()"
      );
    }

    if (!client.EXPIRES) {
      if (client.has) {
        throw new Error(
          `You can only define client.has() when the client manages the expiration; otherwise please do NOT define .has() and let us manage it`
        );
      }
      if (client.keys) {
        throw new Error(
          `You can only define client.keys() when the client manages the expiration; otherwise please do NOT define .keys() and let us manage them`
        );
      }
      if (client.values) {
        console.warn(
          `Since this KV client does not manage expiration, it's better not to define client.values() since it doesn't allow us to evict expired keys`
        );
      }
    }
  }

  #unix(expires) {
    const now = new Date().getTime();
    return expires === null ? null : now + expires * 1000;
  }

  // Check if the given data is fresh or not; if
  #isFresh(data, key) {
    // Should never happen, but COULD happen; schedule it for
    // removal and mark it as stale
    if (!data || !data.value || typeof data !== "object") {
      if (key) this.del(key);
      return false;
    }

    // It never expires, so keep it
    if (data.expires === null) return true;

    // It's fresh, keep it
    if (data.expires > Date.now()) return true;

    // It's expired, remove it
    if (key) this.del(key);
    return false;
  }

  // #region .add()
  /**
   * Save the data on an autogenerated key, can add expiration as well:
   *
   * ```js
   * const key1 = await store.add("value1");
   * const key2 = await store.add({ hello: "world" });
   * const key3 = await store.add("value3", { expires: "1h" });
   * ```
   *
   * **[→ Full .add() Docs](https://polystore.dev/documentation#add)**
   * @param {Value} value
   * @param {{ expires: string }} options
   * @returns {Promise<string>}
   */
  async add(value, options = {}) {
    await this.promise;
    const expires = parse(options.expire ?? options.expires);

    // Use the underlying one from the client if found
    if (this.client.add) {
      if (this.client.EXPIRES) {
        return this.client.add(this.PREFIX, value, { expires });
      }

      // In the data we need the timestamp since we need it "absolute":
      return this.client.add(this.PREFIX, {
        expires: this.#unix(expires),
        value,
      });
    }

    const id = createId();
    await this.set(id, value, { expires });
    return id; // The plain one without the prefix
  }

  // #region .set()
  /**
   * Save the data on the given key, can add expiration as well:
   *
   * ```js
   * const key = await store.set("key1", "value1");
   * await store.set("key2", { hello: "world" });
   * await store.set("key3", "value3", { expires: "1h" });
   * ```
   *
   * **[→ Full .set() Docs](https://polystore.dev/documentation#set)**
   * @param {string} key
   * @param {Value} value
   * @param {{ expires: string }} options
   * @returns {Promise<string>}
   */
  async set(key, value, options = {}) {
    await this.promise;
    const id = this.PREFIX + key;
    const expires = parse(options.expire ?? options.expires);

    // Quick delete
    if (value === null || (typeof expires === "number" && expires <= 0)) {
      await this.del(id);
      return key;
    }

    // The client manages the expiration, so let it manage it
    if (this.client.EXPIRES) {
      await this.client.set(id, value, { expires });
      return key;
    }

    // In the data we need the timestamp since we need it "absolute":
    await this.client.set(id, { expires: this.#unix(expires), value });
    return key;
  }

  // #region .get()
  /**
   * Read a single value from the KV store:
   *
   * ```js
   * const value1 = await store.get("key1");
   * // null (doesn't exist or has expired)
   * const value2 = await store.get("key2");
   * // "value2"
   * const value3 = await store.get("key3");
   * // { hello: "world" }
   * ```
   *
   * **[→ Full .get() Docs](https://polystore.dev/documentation#get)**
   * @param {string} key
   * @returns {Promise<Value>}
   */
  async get(key) {
    await this.promise;
    const id = this.PREFIX + key;

    const data = (await this.client.get(id)) ?? null;

    // No value; nothing to do/check
    if (data === null) return null;

    // The client already managed expiration and there's STILL some data,
    // so we can assume it's the raw user data
    if (this.client.EXPIRES) return data;

    if (!this.#isFresh(data, key)) return null;
    return data.value;
  }

  // #region .has()
  /**
   * Check whether a key exists or not:
   *
   * ```js
   * if (await store.has("key1")) { ... }
   * ```
   *
   * If you are going to use the value, it's better to just read it:
   *
   * ```js
   * const val = await store.get("key1");
   * if (val) { ... }
   * ```
   *
   *
   * **[→ Full .has() Docs](https://polystore.dev/documentation#has)**
   * @param {string} key
   * @returns {Promise<boolean>}
   */
  async has(key) {
    await this.promise;
    const id = this.PREFIX + key;

    if (this.client.has) {
      return this.client.has(id);
    }

    const value = await this.get(key);
    return value !== null;
  }

  // #region .del()
  /**
   * Remove a single key and its value from the store:
   *
   * ```js
   * const key = await store.del("key1");
   * ```
   *
   * **[→ Full .del() Docs](https://polystore.dev/documentation#del)**
   * @param {string} key
   * @returns {Promise<string>}
   */
  async del(key) {
    await this.promise;
    const id = this.PREFIX + key;

    if (this.client.del) {
      await this.client.del(id);
      return key;
    }

    await this.client.set(id, null, { expires: 0 });
    return key;
  }

  async *[Symbol.asyncIterator]() {
    await this.promise;

    for await (const [name, data] of this.client.iterate(this.PREFIX)) {
      const key = name.slice(this.PREFIX.length);
      if (this.client.EXPIRES) {
        yield [key, data];
      } else if (this.#isFresh(data, key)) {
        yield [key, data.value];
      }
    }
  }

  // #region .entries()
  /**
   * Return an array of the entries, in the [key, value] format:
   *
   * ```js
   * const entries = await store.entries();
   * // [["key1", "value1"], ["key2", { hello: "world" }], ...]
   *
   * // To limit it to a given prefix, use `.prefix()`:
   * const sessions = await store.prefix("session:").entries();
   * ```
   *
   * **[→ Full .entries() Docs](https://polystore.dev/documentation#entries)**
   * @returns {Promise<[string, Value][]>}
   */
  async entries() {
    await this.promise;

    let list = [];
    if (this.client.entries) {
      list = (await this.client.entries(this.PREFIX)).map(([key, value]) => [
        key.slice(this.PREFIX.length),
        value,
      ]);
    } else {
      for await (const [key, value] of this.client.iterate(this.PREFIX)) {
        list.push([key.slice(this.PREFIX.length), value]);
      }
    }

    // The client already manages the expiration, so we can assume
    // that at this point, all entries are not-expired
    if (this.client.EXPIRES) return list;

    // We need to do manual expiration checking
    return list
      .filter(([key, data]) => this.#isFresh(data, key))
      .map(([key, data]) => [key, data.value]);
  }

  // #region .keys()
  /**
   * Return an array of the keys in the store:
   *
   * ```js
   * const keys = await store.keys();
   * // ["key1", "key2", ...]
   *
   * // To limit it to a given prefix, use `.prefix()`:
   * const sessions = await store.prefix("session:").keys();
   * ```
   *
   * **[→ Full .keys() Docs](https://polystore.dev/documentation#keys)**
   * @returns {Promise<string[]>}
   */
  async keys() {
    await this.promise;

    if (this.client.keys) {
      const list = await this.client.keys(this.PREFIX);
      if (!this.PREFIX) return list;
      return list.map((k) => k.slice(this.PREFIX.length));
    }

    const entries = await this.entries();
    return entries.map((e) => e[0]);
  }

  // #region .values()
  /**
   * Return an array of the values in the store:
   *
   * ```js
   * const values = await store.values();
   * // ["value1", { hello: "world" }, ...]
   *
   * // To limit it to a given prefix, use `.prefix()`:
   * const sessions = await store.prefix("session:").values();
   * ```
   *
   * **[→ Full .values() Docs](https://polystore.dev/documentation#values)**
   * @returns {Promise<Value[]>}
   */
  async values() {
    await this.promise;

    if (this.client.values) {
      const list = this.client.values(this.PREFIX);
      if (this.client.EXPIRES) return list;
      return list
        .filter((data) => this.#isFresh(data))
        .map((data) => data.value);
    }

    const entries = await this.entries();
    return entries.map((e) => e[1]);
  }

  // #region .all()
  /**
   * Return an object with the keys:values in the store:
   *
   * ```js
   * const obj = await store.all();
   * // { key1: "value1", key2: { hello: "world" }, ... }
   *
   * // To limit it to a given prefix, use `.prefix()`:
   * const sessions = await store.prefix("session:").all();
   * ```
   *
   * **[→ Full .all() Docs](https://polystore.dev/documentation#all)**
   * @returns {Promise<{ [key:string]: Value }>}
   */
  async all() {
    await this.promise;

    if (this.client.all) {
      const obj = await this.client.all(this.PREFIX);
      if (!this.PREFIX) return obj;
      const all = {};
      for (let key in obj) {
        all[key.slice(this.PREFIX.length)] = obj[key];
      }
      return all;
    }

    const entries = await this.entries();
    return Object.fromEntries(entries);
  }

  // #region .clear()
  /**
   * Delete all of the records of the store:
   *
   * ```js
   * await store.clear();
   * ```
   *
   * It's useful for cache invalidation, clearing the data, and testing.
   *
   * **[→ Full .clear() Docs](https://polystore.dev/documentation#clear)**
   * @returns {Promise<null>}
   */
  async clear() {
    await this.promise;

    if (this.client.clear) {
      return this.client.clear(this.PREFIX);
    }

    const keys = await this.keys();
    // Note: this gives trouble of concurrent deletes in the FS
    await Promise.all(keys.map((key) => this.del(key)));
  }

  // #region .prefix()
  /**
   * Create a substore where all the keys are stored with
   * the given prefix:
   *
   * ```js
   * const session = store.prefix("session:");
   * await session.set("key1", "value1");
   * console.log(await session.entries());  // session.
   * // [["key1", "value1"]]
   * console.log(await store.entries());  // store.
   * // [["session:key1", "value1"]]
   * ```
   *
   * **[→ Full .prefix() Docs](https://polystore.dev/documentation#prefix)**
   * @returns {Store}
   */
  prefix(prefix = "") {
    const store = new Store(
      Promise.resolve(this.promise).then((client) => client || this.client)
    );
    store.PREFIX = this.PREFIX + prefix;
    return store;
  }

  // #region .close()
  /**
   * Stop the connection to the store, if any:
   *
   * ```js
   * await session.set("key1", "value1");
   * await store.close();
   * await session.set("key2", "value2");  // error
   * ```
   *
   * **[→ Full .close() Docs](https://polystore.dev/documentation#close)**
   * @returns {Store}
   */
  async close() {
    await this.promise;

    if (this.client.close) {
      return this.client.close();
    }
  }
}

export default (client) => new Store(client);
