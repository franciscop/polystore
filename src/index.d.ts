export type Options = { expires?: number | string | null };
export type Value = string | { [key: string]: Value } | Value[];

export interface Store {
  /**
   * Save the data on an autogenerated key, can add expiration as well:
   *
   * ```js
   * const key1 = await store.add("value1");
   * const key2 = await store.add({ hello: "world" });
   * const key3 = await store.add("value3", { expires: "1h" });
   * ```
   *
   * **[→ Full .add() Docs](https://polystore.dev/documentation#add)**
   */
  add: <T = Value>(value: T, options?: Options) => Promise<string>;

  /**
   * Save the data on the given key, can add expiration as well:
   *
   * ```js
   * const key = await store.set("key1", "value1");
   * await store.set("key2", { hello: "world" });
   * await store.set("key3", "value3", { expires: "1h" });
   * ```
   *
   * **[→ Full .set() Docs](https://polystore.dev/documentation#set)**
   */
  set: <T = Value>(key: string, value: T, options?: Options) => Promise<string>;

  /**
   * Read a single value from the KV store:
   *
   * ```js
   * const value1 = await store.get("key1");
   * // null (doesn't exist or has expired)
   * const value2 = await store.get("key2");
   * // "value2"
   * const value3 = await store.get("key3");
   * // { hello: "world" }
   * ```
   *
   * **[→ Full .get() Docs](https://polystore.dev/documentation#get)**
   */
  get: <T = Value>(key: string) => Promise<T | null>;

  /**
   * Check whether a key exists or not:
   *
   * ```js
   * if (await store.has("key1")) { ... }
   * ```
   *
   * If you are going to use the value, it's better to just read it:
   *
   * ```js
   * const val = await store.get("key1");
   * if (val) { ... }
   * ```
   *
   *
   * **[→ Full .has() Docs](https://polystore.dev/documentation#has)**
   */
  has: (key: string) => Promise<boolean>;

  /**
   * Remove a single key and its value from the store:
   *
   * ```js
   * const key = await store.del("key1");
   * ```
   *
   * **[→ Full .del() Docs](https://polystore.dev/documentation#del)**
   */
  del: (key: string) => Promise<string>;

  /**
   * Return an array of the entries, in the [key, value] format:
   *
   * ```js
   * const entries = await store.entries();
   * // [["key1", "value1"], ["key2", { hello: "world" }], ...]
   *
   * // To limit it to a given prefix, use `.prefix()`:
   * const sessions = await store.prefix("session:").entries();
   * ```
   *
   * **[→ Full .entries() Docs](https://polystore.dev/documentation#entries)**
   */
  entries: <T = Value>() => Promise<[key: string, value: T][]>;

  /**
   * Return an array of the keys in the store:
   *
   * ```js
   * const keys = await store.keys();
   * // ["key1", "key2", ...]
   *
   * // To limit it to a given prefix, use `.prefix()`:
   * const sessions = await store.prefix("session:").keys();
   * ```
   *
   * **[→ Full .keys() Docs](https://polystore.dev/documentation#keys)**
   */
  keys: () => Promise<string[]>;

  /**
   * Return an array of the values in the store:
   *
   * ```js
   * const values = await store.values();
   * // ["value1", { hello: "world" }, ...]
   *
   * // To limit it to a given prefix, use `.prefix()`:
   * const sessions = await store.prefix("session:").values();
   * ```
   *
   * **[→ Full .values() Docs](https://polystore.dev/documentation#values)**
   */
  values: <T = Value>() => Promise<T[]>;

  /**
   * Return an object with the keys:values in the store:
   *
   * ```js
   * const obj = await store.all();
   * // { key1: "value1", key2: { hello: "world" }, ... }
   *
   * // To limit it to a given prefix, use `.prefix()`:
   * const sessions = await store.prefix("session:").all();
   * ```
   *
   * **[→ Full .all() Docs](https://polystore.dev/documentation#all)**
   */
  all: <T = Value>() => Promise<{ [key: string]: T }>;

  /**
   * Delete all of the records of the store:
   *
   * ```js
   * await store.clear();
   * ```
   *
   * It's useful for cache invalidation, clearing the data, and testing.
   *
   * **[→ Full .clear() Docs](https://polystore.dev/documentation#clear)**
   */
  clear: () => Promise<null>;

  /**
   * Create a substore where all the keys are stored with
   * the given prefix:
   *
   * ```js
   * const session = store.prefix("session:");
   * await session.set("key1", "value1");
   * console.log(await session.entries());  // session.
   * // [["key1", "value1"]]
   * console.log(await store.entries());  // store.
   * // [["session:key1", "value1"]]
   * ```
   *
   * **[→ Full .prefix() Docs](https://polystore.dev/documentation#prefix)**
   */
  prefix: (prefix: string) => Store;

  /**
   * Stop the connection to the store, if any:
   *
   * ```js
   * await session.set("key1", "value1");
   * await store.close();
   * await session.set("key2", "value2");  // error
   * ```
   *
   * **[→ Full .close() Docs](https://polystore.dev/documentation#close)**
   */
  close?: () => Promise<null>;

  /**
   * An iterator that goes through all of the key:value pairs in the client
   *
   * ```js
   * for await (const [key, value] of store) {
   *   console.log(key, value);
   * }
   * ```
   *
   * **[→ Full Iterator Docs](https://polystore.dev/documentation#iterator)**
   */
  [Symbol.asyncIterator]: () => {
    next: () => Promise<{ value: [string, Value] }>;
  };
}

export default function (store?: any): Store;
